{
  "hash": "5a95df47eb338cc88c6fa6d471fdf145",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 6\"\nauthor: \"Yang Lu\"\ndate: \"21 May 2025\"\ndate-modified: \"last-modified\"\nformat: html\neditor: visual\nexecute: \n  eval: true  \n  echo: true  \n  warning: false \n  freeze: true \n---\n\n\n\n# **Lesson 10: Visualising and Analysing Time-oriented Data**\n\n## **10.1 Learning Outcome**\n\nBy the end of this hands-on exercise , will be able create the followings data visualisation by using R packages:\n\n-   plotting a calender heatmap by using ggplot2 functions,\n\n-   plotting a cycle plot by using ggplot2 function,\n\n-   plotting a slopegraph\n\n-   plotting a horizon chart\n\n## **10.2 Getting Started**\n\n## 10.3 Loading packages\n\nInstalling and launch the following R packages: scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table and tidyverse.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(scales, viridis, lubridate, ggthemes,\n               gridExtra, readxl, knitr, data.table,\n               CGPfunctions, ggHoriPlot, tidyverse)\n```\n:::\n\n\n\n## **10.4 Plotting Calendar Heatmap**\n\nIn this section, will learn how to plot a calender `heatmap programmatically` by using ggplot2 package.\n\n![By the end of this section, will be able to:](images/clipboard-1041574546.png)\n\n-   plot a calender heatmap by using ggplot2 functions and extension,\n\n-   to write function using R programming,\n\n-   to derive specific date and time related field by using base R and lubridate packages\n\n-   to perform data preparation task by using tidyr and dplyr packages.\n\n### **10.4.1 The Data**\n\nFor the purpose of this hands-on exercise, *eventlog.csv* file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.\n\n### **10.4.2 Importing the data**\n\nFirst, you will use the code chunk below to import *eventlog.csv* file into R environment and called the data frame as *attacks*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks <- read_csv(\"data/eventlog.csv\")\n```\n:::\n\n\n\n### **10.4.3 Examining the data structure**\n\nIt is always a good practice to examine the imported data frame before further analysis is performed.\n\nFor example, *`kable()`* can be used to review the structure of the imported data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n\n\n:::\n:::\n\n\n\nReferring to above list, There are three columns, namely *timestamp*, *source_country* and *tz*.\n\n-   *timestamp* field stores date-time values in **POSIXct format**.\n\n-   *source_country* field stores the source of the attack. It is in *ISO 3166-1 alpha-2* country code.\n\n-   *tz* field stores time zone of the source IP address.\n\n### **10.4.4 Data Preparation**\n\n#### **Step 1: Deriving *weekday* and *hour of day* fields**\n\nBefore we can plot the calender heatmap, two new fields namely *`wkday`* and *`hour`* need to be derived.\n\nIn this step, we will write a function to perform the task.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n\n::: callout-note\n-   [`ymd_hms()`](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [`hour()`](https://lubridate.tidyverse.org/reference/hour.html) are from [**lubridate**](https://lubridate.tidyverse.org/) package, and\n\n-   [`weekdays()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a **base** R function.\n:::\n\n#### **Step 2: Deriving the attacks tibble data frame**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n\n\n::: callout-note\nBeside extracting the necessary data into *attacks* data frame, `mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into **factor** so they’ll be ordered when plotting\n:::\n\n::: {.callout-caution icon=\"false\"}\n## Explain the above code chunk:\n\n-   `group_by(tz)`: Split the data by each time-zone (`tz`) value.\n\n-   `do(make_hr_wkday(...))`: For each group, call your helper function `make_hr_wkday()`, which returns a small table with three columns:\n\n1.  `source_country` (passed through)\n\n2.  `wkday` (the weekday name of each timestamp)\n\n3.  `hour` (the hour of day, 0–23)\n\n-   `ungroup()`: Recombine all those group outputs back into one big tibble.\n\n-   `mutate(...)`: Convert both `wkday` and `hour` into **ordered factors** with the levels you specified. That way, when you plot or tabulate, the categories will appear in chronological order (Sat → Fri → … → Sun and 0 → 1 → … → 23).\n:::\n\nTable below shows the tidy tibble table after processing.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n\n\n:::\n:::\n\n\n\n### **10.4.5 Building the Calendar Heatmaps**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n::: callout-tip\n## Things to learn from the code above:\n\n-   a tibble data table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields.\n\n-   a new field called *n* is derived by using `group_by()` and `count()` functions.\n\n-   `na.omit()` is used to exclude missing value.\n\n-   `geom_tile()` is used to plot tiles (grids) at each x and y position. `color` and `size` arguments are used to specify the border color and line size of the tiles.\n\n-   [`theme_tufte()`](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of [**ggthemes**](https://jrnold.github.io/ggthemes/reference/index.html) package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.\n\n-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.\n\n-   `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).\n:::\n\nexplain the above code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Summarise attacks by weekday & hour\ngrouped <- attacks %>%\n  count(wkday, hour) %>%   # 2. Count rows for each (wkday, hour) → creates column `n`\n  ungroup() %>%            # 3. Drop any grouping metadata\n  na.omit()                # 4. Remove rows with NA in wkday, hour, or n\n\n# 5. Build the calendar‐style heatmap\nggplot(grouped,\n       aes(x = hour,\n           y = wkday,\n           fill = n)) +       # 6. Map `hour` → x, `wkday` → y, `n` → fill color\n  geom_tile(color = \"white\",\n            size  = 0.1) +    # 7. Draw each cell as a tile with a thin white border\n  theme_tufte(base_family = \"Helvetica\") +  # 8. Apply a clean Tufte theme with Helvetica font\n  coord_equal() +                       # 9. Ensure x and y scales use equal units (square tiles)\n  scale_fill_gradient(\n    name = \"# of attacks\",     # 10. Legend title\n    low  = \"sky blue\",         # 11. Color for low values\n    high = \"dark blue\"         # 12. Color for high values\n  ) +\n  labs(\n    x     = NULL,              # 13. Remove x‐axis label\n    y     = NULL,              # 14. Remove y‐axis label\n    title = \"Attacks by weekday and time of day\"  # 15. Plot title\n  ) +\n  theme(\n    axis.ticks   = element_blank(),             # 16. Hide axis tick marks\n    plot.title   = element_text(hjust = 0.5),   # 17. Center the title\n    legend.title = element_text(size = 8),      # 18. Legend title font size\n    legend.text  = element_text(size = 6)       # 19. Legend item font size\n  )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\nThen we can simply group the count by hour and wkday and plot it, since we know that we have values for every combination there’s no need to further preprocess the data.\n\n### **10.4.6 Building Multiple Calendar Heatmaps** [\\[Unassisted Trial\\]]{style=\"color:red;\"}\n\nBuilding multiple heatmaps for the top four countries with the highest number of attacks.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# indentify the top 4 source countries by total attack count\ntop4 <- attacks %>%\n  count(source_country) %>%   #count for total attacks per country\n  arrange(desc(n)) %>%        #sort by descending order\n  slice_head(n = 4) %>%       #take the first 4 (top 4) \n  pull(source_country)        #extract the country names\n\n# build weekday/hour counts for those top 4 countries\ngrouped_top4 <- attacks %>%\n  filter(source_country %in% top4) %>%   #only keep top 4 countries\n  count(source_country, wkday, hour) %>% #count attack per (source_contry,wkday,hour)\n  ungroup() %>%\n  na.omit()  #drop any rows with NA\n\n\nggplot(grouped_top4, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \nfacet_wrap(~ source_country, ncol = 2) +    # 2 column of small heatmaps\ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      axis.text.x = element_text(size = 5),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n### **10.4.7 Plotting Multiple Calendar Heatmaps**\n\n#### **Step 1: Deriving attack by country object**\n\nIn order to identify the **top 4 countries** with the **highest** number of attacks, required to do the followings:\n\n-   count the number of attacks by country,\n\n-   calculate the percent of attackes by country, and\n\n-   save the results in a tibble data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks_by_country <- count(\n  attacks, source_country) %>%\n  mutate(percent = percent(n/sum(n))) %>%\n  arrange(desc(n))\n```\n:::\n\n\n\n#### Step 2: Preparing the tidy data frame\n\nIn this step, required to extract the attack records of the top 4 countries from attacks data frame and save the data in a new tibble data frame (i.e. top4_attacks).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop4 <- attacks_by_country$source_country[1:4]\ntop4_attacks <- attacks %>%\n  filter(source_country %in% top4) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  na.omit()\n```\n:::\n\n\n\n::: {.callout-caution icon=\"false\"}\n## Self-note\n\n`mutate(source_country = factor(source_country, levels = top4))`\n\nthe purpose is to convert the **source_country** column into a categorical factor whose categories are ordered exactly as in the `top4` vector.\n\nReason：By default, R will sort or display character group by alphabetically or first appearance, so now convert to a factor with own levels, so that when facet or order data, the four countries appear in the Top 4 sequence.\n:::\n\n### **10.4.8 Plotting Multiple Calendar Heatmaps**\n\n#### Step 3: Plotting the Multiple Calender Heatmap by using ggplot2 package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n## **10.5 Plotting Cycle Plot**\n\nIn this section, will learn how to plot a **cycle plot** showing the `time-series patterns` and `trend of visitor arrivals` from Vietnam programmatically by using **ggplot2 functions.**\n\n![](images/clipboard-3164097906.png)\n\n### **10.5.1 Step 1: Data Import**\n\nFor the purpose of this hands-on exercise, *arrivals_by_air.xlsx* will be used.\n\nThe code chunk below imports *arrivals_by_air.xlsx* by using `read_excel()` of **readxl** package and save it as a tibble data frame called *air*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair <- read_excel(\"data/arrivals_by_air.xlsx\")\nkable(head(air))\n```\n\n::: {.cell-output-display}\n\n\n|Month-Year | Republic of South Africa| Canada|   USA| Bangladesh| Brunei| China| Hong Kong SAR (China)| India| Indonesia| Japan| South Korea| Kuwait| Malaysia| Myanmar| Pakistan| Philippines| Saudi Arabia| Sri Lanka| Taiwan| Thailand| United Arab Emirates| Vietnam| Belgium & Luxembourg|  CIS| Finland| France| Germany| Ireland| Italy| Netherlands| Spain| Switzerland| United Kingdom| Australia| New Zealand|\n|:----------|------------------------:|------:|-----:|----------:|------:|-----:|---------------------:|-----:|---------:|-----:|-----------:|------:|--------:|-------:|--------:|-----------:|------------:|---------:|------:|--------:|--------------------:|-------:|--------------------:|----:|-------:|------:|-------:|-------:|-----:|-----------:|-----:|-----------:|--------------:|---------:|-----------:|\n|2000-01-01 |                     3291|   5545| 25906|       2883|   3749| 33895|                 13692| 19235|     65151| 59288|       21457|    507|    27472|    1177|     2150|        8404|         1312|      3922|  15766|    12048|                 1318|    1527|                 1434| 2703|    1634|   4752|   12739|    1292|  3544|        4962|   925|        3731|          28986|     34616|        5034|\n|2000-02-01 |                     2357|   6120| 28262|       2469|   3236| 34344|                 19870| 18975|     37105| 58188|       19634|    199|    29084|    1161|     2496|        9128|          623|      3988|  24861|    12745|                  899|    2269|                 1596| 1182|    1297|   6391|   13093|    1200|  2897|        5054|   747|        3980|          35148|     26030|        3938|\n|2000-03-01 |                     4036|   6255| 30439|       2904|   3342| 27053|                 17086| 21049|     44205| 74426|       20719|    386|    30504|    1355|     2429|       11691|         1578|      4259|  18767|    16971|                 1474|    2034|                 1548| 1088|    1220|   5528|   13645|    1368|  2717|        4950|   935|        3576|          36117|     31119|        4668|\n|2000-04-01 |                     4241|   4521| 25378|       2843|   5117| 30464|                 22346| 26160|     45480| 49985|       17489|    221|    34478|    1593|     2711|       14141|          705|      6579|  22735|    20397|                 1284|    2420|                 1592| 1012|    1208|   5544|   13366|    1345|  2512|        4149|   941|        3850|          33792|     34824|        6890|\n|2000-05-01 |                     2841|   3914| 26163|       2793|   4152| 30775|                 16357| 35869|     38350| 48937|       19398|    164|    34795|    1397|     2594|       13305|          679|      4625|  18399|    15769|                 1042|    1833|                 1167|  660|     743|   4225|   10878|    1067|  2205|        3643|   764|        3025|          23377|     33139|        7006|\n|2000-06-01 |                     2776|   3487| 28179|       3146|   5018| 26720|                 18133| 31314|     47982| 53798|       17522|    440|    34660|    1715|     2924|       10555|         2749|      4740|  21042|    17217|                 1545|    2480|                 1170|  712|     982|   4047|    9054|    1363|  2196|        3544|   855|        2580|          21769|     35731|        7634|\n\n\n:::\n:::\n\n\n\n### **10.5.2 Step 2: Deriving month and year fields**\n\nNext, two new fields called *month* and *year* are derived from *Month-Year* field.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair$month <- factor(month(air$`Month-Year`),  # extract month number (1–12)\n                    levels=1:12,    # define valid levels\n                    labels=month.abb, \n                    ordered=TRUE)     # keep them in calendar order\nair$year <- year(ymd(air$`Month-Year`))  # parse “Month-Year” as a date\n```\n:::\n\n\n\n### **10.5.3 Step 3: Extracting the targer country**\n\nNext, the code chunk below is use to extract data for the target country (i.e. Vietnam)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVietnam <- air %>% \n  select(`Vietnam`,   # keep only the Vietnam column + month & year\n         month, \n         year) %>%\n  filter(year >= 2010) \n```\n:::\n\n\n\n### **10.5.4 Step 4: Computing year average arrivals by month**\n\nThe code chunk below uses `group_by()` and `summarise()` of **dplyr** to compute year average arrivals by month.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avgvalue = mean(`Vietnam`))\n```\n:::\n\n\n\n::: {.callout-caution icon=\"false\"}\n## Self-note\n\nsummarise(avgvalue = mean(Vietnam))\n\n-   For each month group, compute the average of the `Vietnam` column (i.e. arrivals).\n\n<!-- -->\n\n-   Store that in a new tibble `hline.data` with columns `month` and `avgvalue`.\n:::\n\n### **10.5.5 Step 5: Plotting the cycle plot**\n\nThe code chunk below is used to plot the cycle plot as shown in Slide 12/23.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue),  #Add a horizontal dashed red line at each month’s long-term average.\n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) + #Create a separate small panel for each month (Jan–Dec).\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_tufte(base_family = \"Helvetica\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n## **10.6 Plotting Slopegraph**\n\nIn this section will learn how to plot a [slopegraph](https://www.storytellingwithdata.com/blog/2020/7/27/what-is-a-slopegraph) by using R.\n\nBefore getting start, make sure that **CGPfunctions** has been installed and loaded onto R environment. Then, refer to [Using newggslopegraph](https://cran.r-project.org/web/packages/CGPfunctions/vignettes/Using-newggslopegraph.html) to learn more about the function. Lastly, read more about `newggslopegraph()` and its arguments by referring to this [link](https://www.rdocumentation.org/packages/CGPfunctions/versions/0.6.3/topics/newggslopegraph).\n\n### **10.6.1 Step 1: Data Import**\n\nImport the rice data set into R environment by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice <- read_csv(\"data/rice.csv\")\n```\n:::\n\n\n\n### **10.6.2 Step 2: Plotting the slopegraph**\n\nNext, code chunk below will be used to plot a basic slopegraph as shown below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n# 1. Treat Year as a categorical variable so lines jump between exactly two levels\n  mutate(Year = factor(Year)) %>%  \n#2. Keep only the two endpoints we care about (1961 and 1980)\n  filter(Year %in% c(1961, 1980)) %>%\n#3. Draw the slop graph\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Yang Lu\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex10_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-note icon=\"false\"}\n## Things to learn from code chunk above:\n\nFor effective data visualisation design, `factor()` is used convert the value type of *Year* field from numeric to factor.\n:::\n",
    "supporting": [
      "Hands-on_Ex10_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
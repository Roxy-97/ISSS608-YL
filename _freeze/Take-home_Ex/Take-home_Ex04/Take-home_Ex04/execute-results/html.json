{
  "hash": "a5064fedc69927a3a36a9ab4a98a879b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take home Exercise 3\"\nauthor: \"Yang Lu\"\ndate: \"12 Jun 2025\"\ndate-modified: \"last-modified\"\nformat: html\neditor: visual\nexecute: \n  eval: true  \n  echo: true  \n  warning: false \n  freeze: true \n---\n\n\n\n\n\n# **Take-home Exercise 3: Prototyping Modules for Visual Analytics Shiny Application**\n\n## 1. Overall task\n\n-   To evaluate and determine the necessary R packages needed for your Shiny application are supported in R CRAN,\n\n-   To prepare and test the specific R codes can be run and returned the correct output as expected,\n\n-   To determine the parameters and outputs that will be exposed on the Shiny applications, and\n\n-   To select the appropriate Shiny UI components for exposing the parameters determine above.\n\n## 2. Install packages\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(\nshiny,jsonlite,tidyverse,\nSmartEDA,tidygraph,ggraph,lubridate,\ndplyr,scales,patchwork,plotly)\n```\n:::\n\n\n\n\n\n## 3. Loading data\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMC3_graph <- fromJSON(\"data/MC3_graph.json\")\nnodes_tbl  <- as_tibble(MC3_graph$nodes)\nedges_tbl  <- as_tibble(MC3_graph$edges)\n```\n:::\n\n\n\n\n\n## 4. Task 1.1: Create visual analytics to identify daily patterns in communication timing\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Extract the data only for sub_type=communication\ncomm_nodes <-nodes_tbl %>%\n  filter(type==\"Event\",\n         sub_type == \"Communication\") %>%\n  select(event_id = id,timestamp)\n\n#Extract data from sender and receiver\nsent_edges <-edges_tbl %>% filter(type==\"sent\")%>%\n  select(sender = source,event_id=target)\n\nrecv_edges <-edges_tbl %>% filter(type==\"received\")%>%\n  select(event_id = source,receiver=target)\n\n#using inner_join to combine sender and receiver\nmsgs <- sent_edges %>%\n  inner_join(recv_edges, by=\"event_id\") %>%\n  inner_join(comm_nodes, by=\"event_id\") %>%\n  mutate(ts = ymd_hms(timestamp, tz=\"UTC\")) %>%\n  mutate(date = as_date(ts), hour = hour(ts))\n\n\nheatmap_data <- msgs %>%\n  count(date, hour) %>%\n  complete(\n    date = seq(min(date), max(date), by = \"1 day\"),\n    hour = 0:23,\n    fill = list(n = 0)\n  )\n\n\nui <- fluidPage(\n  titlePanel(\"Heatmap：Daily Communication Patterns\"),\n  sidebarLayout(\n    sidebarPanel(\n  \n      dateRangeInput(\n        inputId = \"date_range\",\n        label   = \"Select date range：\",\n        start   = min(heatmap_data$date),\n        end     = max(heatmap_data$date)\n      ),\n      sliderInput(\n        inputId = \"hour_range\",\n        label   = \"Select hour range：\",\n        min     = 0,\n        max     = 23,\n        value   = c(0, 23),\n        step    = 1,\n        ticks   = FALSE\n      )\n    ),\n    mainPanel(\n      plotOutput(\"heatmap\", height = \"600px\")\n    )\n  )\n)\n\n\nserver <- function(input, output, session) {\n  \n \n  filtered_data <- reactive({\n    req(input$date_range)  \n    heatmap_data %>%\n      filter(\n        date >= input$date_range[1],\n        date <= input$date_range[2],\n        hour >= input$hour_range[1],\n        hour <= input$hour_range[2])\n  })\n  \n\n  output$heatmap <- renderPlot({\n    df <- filtered_data()\n    \n     ggplot(df, aes(x = hour, y = date, fill = n)) +\n      geom_tile(color = \"white\") +\n\n      scale_x_continuous(\n        breaks = seq(input$hour_range[1], input$hour_range[2], by = 1),\n        expand = c(0, 0)\n      ) +\n      scale_y_date(\n        breaks      = seq(min(df$date), max(df$date), by = \"1 day\"),\n        date_labels = \"%b %d\",\n        expand      = c(0, 0)\n      ) +\n      scale_fill_distiller(\n        name      = \"Messages\",\n        palette   = \"Spectral\",\n        direction = 1\n      ) +\n      labs(\n        title = \"Heat map of daily message count by hour\",\n        x     = \"Hours (0–23)\",\n        y     = \"Date\"\n      ) +\n      theme_minimal() +\n      theme(\n        axis.text.x = element_text(hjust = 0.5),\n        axis.text.y = element_text(size = 8),\n        panel.grid  = element_blank()\n      )\n  }, res = 96)\n  \n}\n\n\nshinyApp(ui, server)\n```\n\n::: {.cell-output-display}\n`<div style=\"width: 100% ; height: 400px ; text-align: center; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box;\" class=\"muted well\">Shiny applications not supported in static R Markdown documents</div>`{=html}\n:::\n:::\n\n\n\n\n\n## 4. Task 1.2: Compare the shape of daily rhythm between week 1 and week 2\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_date <-min(msgs$date)\nmsgs <- msgs %>%\n  mutate(\n    week = if_else(date <= min(date) + days(6), \"Week 1\", \"Week 2\")\n  )\n# Count and normalize within each week\nweek_patterns <- msgs %>%\n  count(week, hour) %>%\n  group_by(week) %>%\n  mutate(proportion = n / sum(n)) %>%\n  ungroup()\n\nui <- fluidPage(\n  titlePanel(\"Compare the shape of daily rhythm between week 1 and week 2\"),\n  sidebarLayout(\n    sidebarPanel(\n      checkboxGroupInput(\n        inputId  = \"weeks\",\n        label    = \"Select Comparison Week：\",\n        choices  = c(\"Week 1\", \"Week 2\"),\n        selected = c(\"Week 1\", \"Week 2\")\n    ),\n     sliderInput(\n        inputId = \"hour_range\",\n        label   = \"Select Hourly Interval：\",\n        min     = 0,\n        max     = 23,\n        value   = c(0, 23),\n        step    = 1,\n        ticks   = FALSE\n      )\n    ),\n    mainPanel(\n      plotOutput(\"week_plot\", height = \"450px\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n\n   filtered_patterns <- reactive({\n    req(input$weeks, input$hour_range)\n    week_patterns %>%\n      filter(\n        week %in% input$weeks,\n        hour >= input$hour_range[1],\n        hour <= input$hour_range[2]\n      )\n  })\n\n  output$week_plot <- renderPlot({\n    df <- filtered_patterns()\n    hour_breaks <- seq(min(df$hour), max(df$hour), by = 1)\n    prop_breaks <- seq(\n      0,\n      ceiling(max(df$proportion) * 100) / 100,\n      by = 0.02\n    )\n\n    ggplot(df, aes(x = hour, y = proportion, color = week)) +\n      geom_line(size = 1.2) +\n      geom_point(size = 3) +\n      scale_x_continuous(breaks = hour_breaks) +\n      scale_y_continuous(\n        breaks = prop_breaks,\n        labels = percent_format(accuracy = 1)\n      ) +\n      labs(\n        title = \"Hourly Communication Patterns: Week 1 vs Week 2\",\n        x     = \"Hour of Day\",\n        y     = \"Percent of Total Messages\",\n        color = NULL\n      ) +\n      theme_light(base_size = 12) +\n      theme(\n        plot.title       = element_text(face = \"bold\", size = 16, hjust = 0.5),\n        legend.position  = \"top\",\n        panel.grid.major = element_line(color = \"grey80\"),\n        panel.grid.minor = element_line(color = \"grey90\"),\n        axis.text.x      = element_text(vjust = 0.5),\n        axis.text.y      = element_text(size = 8)\n      )\n  }, res = 96)\n\n}\n\nshinyApp(ui, server)\n```\n\n::: {.cell-output-display}\n`<div style=\"width: 100% ; height: 400px ; text-align: center; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box;\" class=\"muted well\">Shiny applications not supported in static R Markdown documents</div>`{=html}\n:::\n:::\n\n\n\n\n\n## 5. Task 1.3: Focus on a specific entity and use this information to determine who has influence over them.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nentity_info <- nodes_tbl %>%\n  filter(type == \"Entity\") %>%\n  select(id, target_subtype = sub_type)\n\nmsgs2 <- msgs %>%\n  left_join(entity_info, by = c(\"receiver\" = \"id\"))\n\n\ntop_inf <- msgs2 %>%\n  filter(!is.na(receiver)) %>%\n  count(target_subtype, receiver, sender, sort = TRUE) %>%\n  group_by(target_subtype, receiver) %>%\n  slice_max(n, n = 10) %>%\n  ungroup()\n\nsubtypes <- sort(unique(top_inf$target_subtype))\n\nui <- fluidPage(\n  titlePanel(\"Influencer Analysis by Entity Subtype\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId  = \"subtype\",\n        label    = \"Select target_subtype:\",\n        choices  = subtypes,\n        selected = subtypes[1]\n      )\n    ),\n    mainPanel(\n      plotlyOutput(\"inf_plot\", height = \"600px\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n\n  filtered <- reactive({\n    req(input$subtype)\n    top_inf %>% filter(target_subtype == input$subtype)\n  })\n\n  output$inf_plot <- renderPlotly({\n    df <- filtered()\n    p <- ggplot(df, aes(\n        x     = reorder(sender, n, .desc = TRUE),\n        y     = n,\n        fill  = receiver,\n        text  = paste0(\n          \"Subtype: \", input$subtype, \"<br>\",\n          \"Sender: \", sender, \"<br>\",\n          \"Receiver: \", receiver, \"<br>\",\n          \"Count: \", n\n        )\n      )) +\n      geom_col(color = \"white\") +\n      scale_fill_viridis_d(option = \"turbo\", name = \"Receiver\") +\n      coord_flip() +\n      labs(\n        title = paste(\"Top 10 Senders for subtype:\", input$subtype),\n        x     = \"Influencer (Sender)\",\n        y     = \"Message Count\"\n      ) +\n      theme_minimal(base_size = 12) +\n      theme(\n        axis.text.y      = element_text(size = 8),\n        panel.grid.major = element_line(color = \"grey80\"),\n        panel.grid.minor = element_line(color = \"grey90\"),\n        legend.position  = \"bottom\"\n      )\n\n    ggplotly(p, tooltip = \"text\")\n  })\n}\n\nshinyApp(ui, server)\n```\n\n::: {.cell-output-display}\n`<div style=\"width: 100% ; height: 400px ; text-align: center; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box;\" class=\"muted well\">Shiny applications not supported in static R Markdown documents</div>`{=html}\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}